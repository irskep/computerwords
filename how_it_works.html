<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Computer Words: How it works</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" href="static/normalize.css" type="text/css" /><link rel="stylesheet" href="static/default.css" type="text/css" /><link rel="stylesheet" href="style.css" type="text/css" /><link rel="stylesheet" href="static/pygments.css" type="text/css" />
    </head>
    <body>
        <header id="pageheader">
            <a class="header-link" href="index.html"><h1>Computer Words <span class="project-version">v1.0b1</span></h1></a>
            <h2>A system for writing and publishing documentation</h2>
            <div id="navheader"><nav class='previous-page'><a href="roadmap.html">&larr; Roadmap</a></nav><nav class='next-page'><a href="API.html">API &rarr;</a></nav><div style="clear: both;"></div></div>
            <hr>
        </header>
        <main id="pagebody"><article><a href="#How-it-works" name="How-it-works" class='header-anchor'><h1>How it works</h1></a><a href="#Read-the-config" name="Read-the-config" class='header-anchor'><h2>Read the config</h2></a><p>First, Computer Words reads your config file, which tells it which Markdown files you want to include, and in what order. See <a href="configuration.html#Defining-table-of-contents-structure-with-file_hierarchy">Defining table of contents structure with <code>file_hierarchy</code></a> for details.</p><a href="#Parse-the-Markdown-files" name="Parse-the-Markdown-files" class='header-anchor'><h2>Parse the Markdown files</h2></a><p>Then, each file is parsed into a tree, with a <code>CWDocumentNode</code> as the root. These document nodes are then added to a global <code>CWRootNode</code>.</p><p>Each node has a globally unique ID and a <i>name</i> (i.e. type, kind, label).</p><p>So this:</p><figure class='code'><figcaption class='filename'>readme.md</figcaption><div class="highlight"><pre><span></span><span class="k"># </span><span class="gh">Title</span>

some text
</pre></div>
</figure><figure class='code'><figcaption class='filename'>part2.md</figcaption><div class="highlight"><pre><span></span><span class="k"># </span><span class="gh">Part 2</span>

text of part 2
</pre></div>
</figure><p>becomes this:</p><figure class='image graphviz-graph'><img src='f75ef7c9476fbdc933f03c9c67bfbf5b1f6b5ed69eb5e2bb9484a5c16ac3fe71.svg'></img></figure><p>This is all stored in a <code>CWTree</code> object, which allows you to access and mutate the tree in the next step.</p><a href="#Processing" name="Processing" class='header-anchor'><h2>Processing</h2></a><p>Then we apply a processor library to the graph. A <i>library</i> is a mapping of <code>node_name -&gt; [processor]</code>. A <i>processor</i> is a function <code>process(tree, node)</code> which mutates the <code>tree</code> in response to visiting <code>node</code>.</p><p>For example, here&#x27;s a processor that reverses all text:</p><figure class='code'><div class="highlight"><pre><span></span><span class="nd">@library.processor</span><span class="p">(</span><span class="s1">&#39;Text&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">reverse_text</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
    <span class="n">tree</span><span class="o">.</span><span class="n">replace_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">CWTextNode</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">text</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
</pre></div>
</figure><p>The library is applied by traversing the tree in post-order (children before parents). That way, when a node is visited, its subtree is guaranteed to be complete.</p><p>If a processor mutates a child of its node, that node is marked &quot;dirty&quot;. After each post-order traversal of the whole tree, if any nodes are dirty, the tree is traversed again, and only the dirty nodes&#x27; processors will be run.</p><p>Supported mutations are documented on <a href="API.html#computerwords.cwdom.CWTree.CWTree"><code><span class='autodoc-keyword'>class </span><span class='autodoc-identifier'>CWTree</span><span class='autodoc-arguments'>()</span></code><a class='autodoc-source-link' href='https://github.com/irskep/computerwords/blob/master/computerwords/cwdom/CWTree.py#L16'>src</a></a>.</p><a href="#Output" name="Output" class='header-anchor'><h2>Output</h2></a><p>Once the processors have been run until there are no more dirty nodes, it&#x27;s time to do something with the complete tree.</p><p>This is where a <i>writer</i> takes over. The job of a writer is to turn a <code>CWTree</code> into human-readable output of some kind.</p><p>The only writer available right now is the HTML writer. It works by defining a <i>visitor</i> for each node name, where each visitor writes the opening tag, visits its children, and then writes the closing tag.</p><p>Since few people will be writing writers, this is the least well documented part of Computer Words right now.</p></article></main>
        <footer id="pagefooter"><nav class='previous-page'><a href="roadmap.html">&larr; Roadmap</a></nav><nav class='next-page'><a href="API.html">API &rarr;</a></nav><div style="clear: both;"></div></footer>
    </body>
</html>

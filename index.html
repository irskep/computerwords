<!doctype html>
<html>
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <title>Computer Words: A system for writing and publishing documentation</title>
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <link rel="stylesheet" href="static/normalize.css" type="text/css" /><link rel="stylesheet" href="static/default.css" type="text/css" /><link rel="stylesheet" href="style.css" type="text/css" />
    </head>
    <body>
        <header id="pageheader">
            <h1>Computer Words</h1>
            <h2>A system for writing and publishing documentation</h2>
        </header>
        <main id="pagebody"><article><p>Computer Words is a tool and document processing API that helps you write documentation for your software library. It is conceptually similar to <a href='http://sphinx-doc.org/'>Sphinx</a>.</p><p>The page you are reading was written in <a href='#computer-flavored-markdown'>Computer Flavored Markdown</a> and compiled with Computer Words.</p><p><a href='https://github.com/irskep/computerwords'>Computer Words on GitHub</a></p><p><a href='https://github.com/irskep/computerwords/tree/master/docs'>Source code for this page</a></p><h1 skip_toc='True'>Table of Contents</h1><nav class='table-of-contents'><ol><li><a href="#index-Basics">Basics</a></li><li><a href="#computer_flavored_markdown-Computer-Flavored-Markdown">Computer Flavored Markdown</a><ol><li><a href="#computer_flavored_markdown-CommonMark-Plus-">CommonMark “Plus”</a></li><li><a href="#computer_flavored_markdown-The-Plus-generalized-tags-">The “Plus”: generalized <tt>&lt;tags&gt;</tt></a></li><li><a href="#computer_flavored_markdown-Work-in-progress-disclaimer-and-apology">Work-in-progress disclaimer and apology</a></li><li><a href="#computer_flavored_markdown-Limitations">Limitations</a></li></ol></li><li><a href="#how_it_works-How-it-works">How it works</a></li><li><a href="#about-Conceptual-information">Conceptual information</a><ol><li><a href="#about-Why-should-I-use-this-">Why should I use this?</a></li><li><a href="#about-Project-Core-Beliefs">Project Core Beliefs</a></li><li><a href="#about-Value-Proposition">Value Proposition</a><ol><li><a href="#about-The-simplicity-of-Markdown-the-power-tools-of-Sphinx">The simplicity of Markdown, the power tools of Sphinx</a></li><li><a href="#about-HTML-CSS">HTML &amp; CSS</a></li><li><a href="#about-Simple-and-powerful-plugin-API">Simple and powerful plugin API</a></li></ol></li><li><a href="#about-Why-Python-3-5-">Why Python 3.5?</a></li></ol></li><li><a href="#roadmap-Missing-features-roadmap">Missing features &amp; roadmap</a><ol><li><a href="#roadmap-Obvious-missing-features">Obvious missing features</a></li><li><a href="#roadmap-Planned-features">Planned features</a></li></ol></li><li><a href="#related_work-Related-Work">Related Work</a><ol><li><a href="#related_work-Docutils-and-Sphinx">Docutils and Sphinx</a></li><li><a href="#related_work-Pollen">Pollen</a></li><li><a href="#related_work-Butterick-s-Practical-Typography">Butterick&#x27;s Practical Typography</a></li><li><a href="#related_work-Jekyll">Jekyll</a></li></ol></li></ol></nav><a name="index-Basics" class='header-anchor'><h1>Basics</h1></a><p>First, install Python 3.5. (Yes, I&#x27;m serious. See <a href='#why-python-3.5'>Why Python 3.5?</a>) Then get the source code of this project (that&#x27;s right, I haven&#x27;t released it yet) and install the requirements. Now you&#x27;re ready to run! You just need to write a Markdown file and a config.</p><p><tt>docs/index.md</tt>:</p><pre language='markdown filename=docs/index.md'># My Cool Project

Hello world!
</pre><p><tt>docs/conf.json</tt>:</p><pre language='json filename=docs/conf.json'>{
  &quot;site_title&quot;: &quot;My Cool Project&quot;,
  &quot;site_subtitle&quot;: &quot;The coolest project ever&quot;,
  &quot;css_files&quot;: [&quot;style.css&quot;],
  &quot;file_hierarchy&quot;: [&quot;*.md&quot;]
}
</pre><p>command:</p><pre language='sh'>&gt; python3 -m computerwords --conf docs/conf.json
</pre><p>The built docs are now in <tt>docs/build/</tt>.</p><hr /></article><article><a name='computer-flavored-markdown'></a><a name="computer_flavored_markdown-Computer-Flavored-Markdown" class='header-anchor'><h1>Computer Flavored Markdown</h1></a><a name="computer_flavored_markdown-CommonMark-Plus-" class='header-anchor'><h2>CommonMark “Plus”</h2></a><p>First things first: if you write <a href='http://commonmark.org/help/'>CommonMark</a>, you should have no problems. Great!</p><a name="computer_flavored_markdown-The-Plus-generalized-tags-" class='header-anchor'><h2>The “Plus”: generalized <tt>&lt;tags&gt;</tt></h2></a><p>In normal Markdown, whenever you write inline HTML, it&#x27;s passed through to the output verbatim. But in Computer Flavored Markdown, it&#x27;s parsed and can have meaning. It becomes part of the <i>abstract syntax tree</i> and can be changed during compilation.</p><p>Take for example, the <tt>&lt;table-of-contents /&gt;</tt> tag. This is not an HTML tag, but it has meaning in Computer Words. Specifically, there is a set of transforms that collects all your headings, and replaces the contents of <tt>&lt;table-of-contents /&gt;</tt> with:</p><pre language='html'>&lt;nav class=&quot;table-of-contents&quot;&gt;
  &lt;ol&gt;
    &lt;li&gt;
      Heading 1
      &lt;ol&gt;
        &lt;li&gt;Subheading 1&lt;/li&gt;
      &lt;/ol&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/nav&gt;
</pre><p>The means by which this happens is described later.</p><a name="computer_flavored_markdown-Work-in-progress-disclaimer-and-apology" class='header-anchor'><h2>Work-in-progress disclaimer and apology</h2></a><p>You might be thinking to yourself, “oh great, another crappy Markdown variant.” Well, I am thinking the same thing. I did my best to mitigate the damage, but since this is still an early-development project, there are still major problems.</p><p>The goal is to let you write your favorite markup language, assuming that language is Markdown, while also supporting the complex and generalized needs of a software documentation system.</p><p>In an ideal world, I could simply describe Computer Flavored Markdown as “CommonMark, but the output is an abstract syntax tree instead of an HTML string.” In reality, it is exactly that, with two exceptions:</p><ol><li><p>The HTML is parsed by a simple recursive descent parser that I wrote, not a proper spec-following web browser. It was actually written as a BBCode parser. At some point I swapped the square brackets for angle brackets.</p></li><li><p>The awkward marriage of a CommonMark parser, which doesn&#x27;t try to parse HTML but merely faithfully pass it through, and a hand-written HTML parser, is complicated, and in this case buggy, with <strong>extremely bad error messages.</strong></p></li></ol><p>I&#x27;m not yet sure how to solve this problem without forking CommonMark or just writing a lot of really bad hacks.</p><a name="computer_flavored_markdown-Limitations" class='header-anchor'><h2>Limitations</h2></a><p>You can&#x27;t currently wrap multiple lines in a tag like this:</p><pre language='markdown'>&lt;div&gt;

Some stuff in between line breaks (this doesn&#x27;t work yet)

&lt;/div&gt;
</pre><p>Since this is basic and essential, it will be fixed soon.</p><hr /></article><article><a name="how_it_works-How-it-works" class='header-anchor'><h1>How it works</h1></a><p>First, your files are parsed into a tree called the “Computer Words Document Object Model”, or <tt>CWDOM</tt>. So this:</p><pre language='markdown filename=readme.md'># Title

some text
</pre><p>becomes this:</p><div class='graphviz-graph'><img src='1.png'></img></div><p>Then we apply a processor library to the graph. A <i>library</i> is a mapping of <tt>node_name -&gt; [processor]</tt>. A <i>processor</i> is a function like this:</p><pre language='python'>@library.processor(&#x27;xxx&#x27;)  # operate on &#x27;xxx&#x27; nodes
def process_xxx(node_store, node)
    # you can mutate the node, its children, or its
    # ancestors (but not its siblings).
    # In this case, we are swapping the node in place for
    # another node, which will have the original node&#x27;s
    # parent and children.
    node_store.replace_node(node, CWDOMNode(&#x27;yyy&#x27;))
</pre><p>Each node will be processed at least once, in a <i>post-order tree traversal</i> (meaning that a node will be visited before its ancestors). If a node is mutated by another node&#x27;s processor, that node will be marked <i>dirty</i> and its processors will be run again.</p><hr /></article><article><a name="about-Conceptual-information" class='header-anchor'><h1>Conceptual information</h1></a><a name="about-Why-should-I-use-this-" class='header-anchor'><h2>Why should I use this?</h2></a><p>You probably shouldn&#x27;t. It&#x27;s not ready yet.</p><a name="about-Project-Core-Beliefs" class='header-anchor'><h2>Project Core Beliefs</h2></a><ol><li><p>Documentation authors are mostly library maintainers.</p></li><li><p>Library maintainers don&#x27;t want to invest lots of time in their documentation system, because it is a distraction from their work.</p></li><li><p>Therefore, using Computer Words should mostly be obvious. Using it should not require authors to constantly refer to syntax references or other meta-documentation.</p></li><li><p>Since the documentation is for software, Computer Words should make it easy to integrate with software. Plugins (custom tags) are a core feature.</p></li></ol><a name="about-Value-Proposition" class='header-anchor'><h2>Value Proposition</h2></a><a name="about-The-simplicity-of-Markdown-the-power-tools-of-Sphinx" class='header-anchor'><h3>The simplicity of Markdown, the power tools of Sphinx</h3></a><p>Markdown is the language of GitHub, BitBucket, and GitLab. Software developers write Markdown <i>all the time.</i> Since they already know Markdown, why should they learn a different language to write their documentation?</p><p>If you just write a bunch of Markdown files, you end up hosting your docs on a GitHub wiki or some similar abomination. There needs to be some kind of organizing power to bring it together.</p><a name="about-HTML-CSS" class='header-anchor'><h3>HTML &amp; CSS</h3></a><p>The output uses semantic HTML5 markup. That&#x27;s kind of nice.</p><p>It&#x27;s really to include CSS stylesheets. You might think, “I&#x27;m making a web site, so of course I can style it with CSS!” But if you were using <a href='http://sphinx-doc.org'>another tool</a>, you would find this task to be more trouble than you were expecting. Computer Words makes it really, really simple to add your own CSS. And it includes a normalization stylesheet and some pretty good defaults.</p><p>Applying some basic font and color changes is a surprisingly affective way to brand your documentation. You should do it.</p><a name="about-Simple-and-powerful-plugin-API" class='header-anchor'><h3>Simple and powerful plugin API</h3></a><p>This isn&#x27;t really true until I document the API, but trust me...it&#x27;s good.</p><a name='why-python-3.5'></a><a name="about-Why-Python-3-5-" class='header-anchor'><h2>Why Python 3.5?</h2></a><p>Most importantly, because it is a pleasure to write. Computer Words uses <tt>pathlib</tt> and <tt>yield from</tt> extensively.</p><p>But also, it forces us to treat earlier versions of Python as a <i>separate language</i>, which makes us more likely to write a better API to support non-Python-3.5 languages!</p><p>I suspect the project runs fine under Python 3.4. But since few people even run Python 3, it might as well be written in OCaml.</p><hr /></article><article><a name="roadmap-Missing-features-roadmap" class='header-anchor'><h1>Missing features &amp; roadmap</h1></a><a name="roadmap-Obvious-missing-features" class='header-anchor'><h2>Obvious missing features</h2></a><ul><li><p>Tag reference documentation</p></li><li><p>Multi-file HTML output (1:1 input-output file mapping)</p></li><li><p>Cross-referencing sections without having to repeat the full name</p></li><li><p>Syntax highlighting in code blocks</p></li><li><p>Reasonable error messages (do you like 50 line stack traces???)</p></li></ul><a name="roadmap-Planned-features" class='header-anchor'><h2>Planned features</h2></a><ul><li><p>External plugin loading</p></li><li><p>Plugin API documentation</p></li></ul><hr /></article><article><a name="related_work-Related-Work" class='header-anchor'><h1>Related Work</h1></a><a name="related_work-Docutils-and-Sphinx" class='header-anchor'><h2>Docutils and Sphinx</h2></a><p>The biggest inspiration for this project is the pairing of <a href='http://docutils.sourceforge.net/'>Docutils</a> and <a href='http://sphinx-doc.org'>Sphinx</a>. They have a similar design: a parser turns text documents into a tree, some transforms are done on the tree (including user plugins), and the output is written to HTML.</p><p>My pain points with this system are why I started from scratch. Docutils is an old, old project with less-than-great documentation, verbose code that supports Python 2.4(!), and Sourceforge SVN hosting. reStructuredText is hard to remember and in many cases incapable of producing certain markup. Sphinx supports many documentation use cases out of the box, but its plugin API is limited, its tree processing algorithm makes it difficult to write certain kinds of useful plugins, and its theming system is not straightforward. (I should know, <a href='http://sphinx-better-theme.readthedocs.org/en/latest/'>I made a theme.</a>)</p><a name="related_work-Pollen" class='header-anchor'><h2>Pollen</h2></a><p>Pollen gets a lot of things right. It is more conceptually pure and seemingly more powerful than Computer Words, and if I had the time to grok its docs, I&#x27;m sure I would enjoy using it.</p><p>But its Markdown mode doesn&#x27;t let you use custom tags (I think?), so you get to pick extensibility, or a markup syntax you already know, but not both.</p><p>Sometimes I can&#x27;t quite convince myself that I&#x27;m not just making a worse version of Pollen using Python. But I honestly think that “native” Markdown documentation is the best way to get contributions from users and buy-in from library maintainers. And reading Pollen&#x27;s documentation, I just don&#x27;t get the impression that we really share a target audience.</p><a name="related_work-Butterick-s-Practical-Typography" class='header-anchor'><h2>Butterick&#x27;s Practical Typography</h2></a><p>The author of Pollen is Matthew Butterick, author of <a href='http://practicaltypography.com'>Practical Typography</a>. It&#x27;s a fun and useful read. Many of the defaults in Computer Words are based on its advice. Mr. Butterick <a href='http://practicaltypography.com/websites.html'>feels the same way I do about Sphinx&#x27;s default themes</a>.</p><a name="related_work-Jekyll" class='header-anchor'><h2>Jekyll</h2></a><p><a href='http://jekyllrb.com/'>Jekyll</a> is a static site generator that understands Markdown. It is not good for writing your documentation.</p><hr /></article></main>
        <footer id="pagefooter">
        </footer>
    </body>
</html>
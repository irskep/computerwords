#!/usr/bin/env python3.5
import argparse
import ast
import json
import pathlib
import sys


next_id = 0
def get_next_id():
    global next_id
    next_id += 1
    return next_id


MODULE_NAME_TO_ID = {}


def parse_data(root, path):
    parts = path.relative_to(root).parts
    if parts and parts[-1] == '__init__.py':
        parts = parts[:-1]

    if parts[-1].endswith('.py'):
        parts = parts[:-1] + (parts[-1][:-3],)
    module_full_name = '.'.join(parts)
    module_display_name = parts[-1]
    module_id = get_next_id()

    MODULE_NAME_TO_ID[module_full_name] = module_id

    module_parent_id = None
    if len(parts) > 1:
        module_parent_id = MODULE_NAME_TO_ID.get('.'.join(parts[:-1]), None)
    else:
        module_parent_id = None

    with path.open('r') as f:
        module = ast.parse(f.read())
        yield {
            'id': module_id,
            'type': 'module',
            'name': module_display_name,
            'docstring': ast.get_docstring(module),
            'parent': module_parent_id,
        }
        for node in module.body:
            if isinstance(node, ast.FunctionDef):
                yield {
                    'id': get_next_id(),
                    'type': 'function',
                    'name': node.name,
                    'docstring': ast.get_docstring(node),
                    'parent': module_id,
                }
            elif isinstance(node, ast.ClassDef):
                class_id = get_next_id()
                yield {
                    'id': class_id,
                    'type': 'class',
                    'name': node.name,
                    'docstring': ast.get_docstring(node),
                    'parent': module_id,
                }
                # sys.stderr.write(repr(node._fields))
                # sys.stderr.write('\n')
                for class_node in node.body:
                    if isinstance(class_node, ast.FunctionDef):
                        yield {
                            'id': get_next_id(),
                            'type': 'method',
                            'name': class_node.name,
                            'docstring': ast.get_docstring(class_node),
                            'parent': class_id,
                        }


def main():
    p = argparse.ArgumentParser()
    p.add_argument('root', default=None, action='store', help=(
        'Directory in which to search for the module'))
    p.add_argument('module', default=None, action='store', help=(
        'Name of the module to parse'))
    p.add_argument('output_file', type=argparse.FileType('w'), help=(
        'Where to write the output'
        ))
    args = p.parse_args()

    root_path = pathlib.Path(args.root).resolve()
    module_root = root_path / args.module

    data = {
        'language': 'python3.5',
        'entries': []
    }
    for py_file_path in module_root.glob('**/*.py'):
        for item in list(parse_data(root_path, py_file_path)):
            sys.stdout.write(json.dumps(item))
            sys.stdout.write('\n')


if __name__ == '__main__':
    main()